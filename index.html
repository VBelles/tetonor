<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetonor Puzzle</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .grid-cell {
            min-height: 110px;
        }

        .strip-cell {
            min-width: 0;
            flex: 1 0 6.25%;
            height: 55px;
        }

        .border-thick {
            border-width: 3px !important;
        }

        /* Input styling to keep it clean */
        input[type="number"],
        select {
            border: 1px solid black !important;
            border-radius: 0 !important;
            padding: 0 !important;
            text-align: center;
        }

        .strip-cell input {
            border: none !important;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .grid-number {
            font-size: 2rem;
        }

        .correct {
            background-color: #d1e7dd !important;
        }

        .incorrect {
            background-color: #f8d7da !important;
        }

        /* Shared Border Input Group */
        .grid-inputs-container {
            display: flex;
            width: 100%;
            border-top: 1px solid black;
        }

        .grid-inputs-container input,
        .grid-inputs-container select {
            flex: 1;
            width: 0;
            /* Allow shrinking below content width */
            min-width: 0;
            border: none !important;
            border-right: 1px solid black !important;
            height: 40px;
            background: transparent;
        }

        .grid-inputs-container select {
            flex: 0 0 40px;
            /* Operator needs less space */
        }

        .grid-inputs-container input:last-child {
            border-right: none !important;
        }

        .grid-inputs-container input:focus,
        .grid-inputs-container select:focus {
            z-index: 5;
            outline: none !important;
            box-shadow: inset 0 0 0 2px #0d6efd !important;
        }

        /* Responsive scaling to keep 4 columns and fit everything */
        @media (max-width: 768px) {
            .grid-cell {
                min-height: 85px !important;
                padding: 0 !important;
            }

            .grid-number {
                font-size: 1.3rem !important;
                padding: 0.5rem 0 !important;
            }

            .grid-inputs-container input,
            .grid-inputs-container select {
                height: 32px !important;
                font-size: 0.8rem !important;
            }

            .grid-inputs-container select {
                flex: 0 0 30px !important;
            }

            .strip-cell {
                flex: 1 0 12.5% !important;
                /* 8 items per row */
                height: 40px !important;
            }

            .strip-cell input,
            .strip-cell span {
                font-size: 0.9rem !important;
            }

            .container {
                padding-left: 5px;
                padding-right: 5px;
            }
        }

        @media (max-width: 400px) {
            .grid-cell {
                min-height: 75px !important;
            }

            .grid-number {
                font-size: 1.1rem !important;
            }

            .grid-inputs-container input,
            .grid-inputs-container select {
                height: 28px !important;
            }
        }
    </style>
</head>

<body class="bg-light">
    <div class="container py-4" style="max-width: 1000px;">
        <div class="text-center mb-4">
            <h1 class="display-5 fw-bold">Tetonor</h1>
            <div class="d-flex justify-content-center gap-2">
                <span class="badge bg-primary px-3 rounded-pill" id="difficulty-badge">MEDIUM</span>
                <span class="badge bg-secondary px-3 rounded-pill" id="seed-badge">Seed: 1</span>
            </div>
        </div>

        <div class="d-flex flex-wrap justify-content-center gap-2 mb-4">
            <div class="btn-group btn-group-sm">
                <button class="btn btn-outline-dark" id="diff-easy">Easy</button>
                <button class="btn btn-outline-dark active" id="diff-medium">Medium</button>
                <button class="btn btn-outline-dark" id="diff-hard">Hard</button>
            </div>
            <div class="btn-group btn-group-sm">
                <button class="btn btn-dark" id="prev-btn">‚Üê Prev</button>
                <button class="btn btn-dark" id="next-btn">Next ‚Üí</button>
            </div>
            <div class="btn-group btn-group-sm">
                <button class="btn btn-danger" id="reset-btn">‚Ü∫ Reset</button>
                <button class="btn btn-info text-white" id="solve-btn">üí° Solve</button>
            </div>
            <button class="btn btn-success btn-sm px-4" id="check-btn">‚úì Check Solution</button>
        </div>

        <div id="grid" class="row g-0 border-dark border-thick mx-auto border" style="max-width: fit-content;"></div>
        <div id="strip" class="d-flex flex-wrap border-dark border-thick mx-auto border mt-4 mb-4"
            style="max-width: fit-content;"></div>

        <div class="alert alert-info border-0 shadow-sm mt-5 pt-4">
            <h6 class="text-center fw-bold mb-3"><i class="bi bi-info-circle me-2"></i>How to Play</h6>
            <div class="row justify-content-center">
                <div class="col-md-9">
                    <ul class="list-unstyled">
                        <li class="mb-2">üìã <strong>Objective:</strong> Form the 16 grid numbers using 8 pairs from the
                            strip.</li>
                        <li class="mb-2">‚ûï <strong>Equations:</strong> Each grid number = (Number A) <strong>+</strong>
                            or <strong>√ó</strong> (Number B).</li>
                        <li class="mb-2">üîÑ <strong>The Twice Rule:</strong> Each pair must be used <strong>exactly
                                twice</strong>: once for addition (+) and once for multiplication (√ó).</li>
                        <li class="mb-2">üìè <strong>Strip Order:</strong> All 16 numbers in the strip are <strong>sorted
                                in ascending order</strong>.</li>
                    </ul>
                    <hr class="my-3 opacity-10">
                    <p class="text-center small text-muted mb-0">Progress is automatically saved to your browser and the
                        URL hash.</p>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="generator.js"></script>
    <script src="validator.js"></script>
    <script src="solver.js"></script>
    <script>
        let currentPuzzle = null;
        let solver = new TetonorSolver();

        function parseHash() {
            const hash = window.location.hash.slice(1);
            const params = hash.split('/');
            let difficulty = params[0];
            if (!['easy', 'medium', 'hard'].includes(params[0])) {
                difficulty = 'medium';
            }
            const seed = parseInt(params[1]) || 1;
            const state = params[2] || null;

            if (seed != parseInt(params[1]) || difficulty != params[0]) {
                updateHash(seed, difficulty, state);
            }
            return { seed, difficulty, state };
        }

        function updateHash(seed, difficulty, state = null) {
            let hash = `${difficulty}/${seed}`;
            if (state) hash += `/${state}`;
            window.location.hash = hash;
        }

        // Compact Sparse Map Encoding (Index + Value)
        // Indices 0-15: Strip
        // Indices 16-63: Grid (16 cells * 3)
        const ALPHA = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_";

        function encodeState() {
            const inputs = [];
            // 1. Collect all 64 possible inputs
            for (let i = 0; i < 16; i++) {
                const el = document.querySelector(`[data-strip-index="${i}"]`);
                inputs.push(el ? el.value : "");
            }
            for (let i = 0; i < 16; i++) {
                inputs.push(
                    document.querySelector(`[data-grid-index="${i}"][data-input-type="num1"]`).value,
                    document.querySelector(`[data-grid-index="${i}"][data-input-type="op"]`).value,
                    document.querySelector(`[data-grid-index="${i}"][data-input-type="num2"]`).value
                );
            }

            // 2. Only store non-empty values
            const sparse = [];
            inputs.forEach((val, i) => {
                if (val !== "" && val !== null) {
                    let v = val;
                    if (v === "+") v = "p";
                    if (v === "√ó") v = "m";
                    sparse.push(ALPHA[i] + v);
                }
            });

            return sparse.join(".");
        }

        function decodeState(encoded) {
            if (!encoded) return null;
            try {
                const state = { s: Array(16).fill(""), g: Array(48).fill("") };
                const pairs = encoded.split(".");

                pairs.forEach(pair => {
                    const char = pair[0];
                    const val = pair.slice(1);
                    const index = ALPHA.indexOf(char);

                    if (index !== -1) {
                        let v = val;
                        if (v === "p") v = "+";
                        if (v === "m") v = "√ó";

                        if (index < 16) {
                            state.s[index] = v;
                        } else {
                            state.g[index - 16] = v;
                        }
                    }
                });
                return state;
            } catch (e) {
                console.error("Failed to decode state", e);
                return null;
            }
        }

        function saveState() {
            if (!currentPuzzle) return;
            const { seed, difficulty } = parseHash();
            const encoded = encodeState();

            localStorage.setItem(`tetonor_${difficulty}_${seed}`, encoded);

            // Construct hash (no trailing / if empty)
            let hash = `${difficulty}/${seed}`;
            if (encoded) hash += `/${encoded}`;
            history.replaceState(null, null, `#${hash}`);
        }

        function loadState() {
            if (!currentPuzzle) return;
            const { seed, difficulty, state: urlState } = parseHash();

            const encoded = urlState || localStorage.getItem(`tetonor_${difficulty}_${seed}`);

            if (encoded) {
                const state = decodeState(encoded);
                if (state) {
                    state.s.forEach((val, i) => {
                        const input = document.querySelector(`[data-strip-index="${i}"]`);
                        if (input) input.value = val;
                    });
                    for (let i = 0; i < 48; i++) {
                        const cellIdx = Math.floor(i / 3);
                        const typeIdx = i % 3;
                        const types = ["num1", "op", "num2"];
                        const input = document.querySelector(`[data-grid-index="${cellIdx}"][data-input-type="${types[typeIdx]}"]`);
                        if (input) input.value = state.g[i];
                    }
                }
            }
        }

        function renderPuzzle() {
            const { seed, difficulty } = parseHash();
            const generator = new TetonorGenerator(seed);
            currentPuzzle = generator.generate(difficulty);

            document.getElementById('difficulty-badge').textContent = difficulty.toUpperCase();
            document.getElementById('seed-badge').textContent = `Seed: ${seed}`;

            ['easy', 'medium', 'hard'].forEach(diff => {
                const btn = document.getElementById(`diff-${diff}`);
                if (btn) btn.classList.toggle('active', diff === difficulty);
            });

            renderGrid();
            renderStrip();
            loadState();
        }

        function renderGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = currentPuzzle.grid.map((value, index) => `
                <div class="col-3 border border-dark text-center bg-white grid-cell d-flex flex-column overflow-hidden">
                    <div class="grid-number flex-grow-1 d-flex align-items-center justify-content-center py-2">${value}</div>
                    <div class="grid-inputs-container">
                        <input type="number" data-grid-index="${index}" data-input-type="num1">
                        <select data-grid-index="${index}" data-input-type="op">
                            <option value=""></option>
                            <option value="+">+</option>
                            <option value="√ó">√ó</option>
                        </select>
                        <input type="number" data-grid-index="${index}" data-input-type="num2">
                    </div>
                </div>
            `).join('');

            // Add auto-save listeners
            grid.querySelectorAll('input, select').forEach(el => {
                el.addEventListener('input', saveState);
            });
        }

        function renderStrip() {
            const strip = document.getElementById('strip');
            strip.innerHTML = currentPuzzle.strip.map((value, index) => `
                <div class="border border-dark text-center bg-white strip-cell d-flex align-items-center justify-content-center p-0">
                    ${value === null
                    ? `<input type="number" data-strip-index="${index}" class="w-100 h-100 text-center border-0 p-0 fs-5 fw-bold">`
                    : `<span class="fw-bold fs-5">${value}</span>`
                }
                </div>
            `).join('');

            // Add auto-save listeners
            strip.querySelectorAll('input').forEach(el => {
                el.addEventListener('input', saveState);
            });
        }

        function checkSolution() {
            // Collect strip inputs
            const stripInputs = [];
            currentPuzzle.strip.forEach((value, index) => {
                if (value === null) {
                    const input = document.querySelector(`[data-strip-index="${index}"]`);
                    stripInputs[index] = parseInt(input.value);
                } else {
                    stripInputs[index] = null;
                }
            });

            // Collect grid inputs
            const gridInputs = [];
            for (let i = 0; i < 16; i++) {
                const num1 = parseInt(document.querySelector(`[data-grid-index="${i}"][data-input-type="num1"]`).value);
                const op = document.querySelector(`[data-grid-index="${i}"][data-input-type="op"]`).value;
                const num2 = parseInt(document.querySelector(`[data-grid-index="${i}"][data-input-type="num2"]`).value);
                gridInputs.push({ num1, op, num2 });
            }

            // Validate
            const result = TetonorValidator.validate(currentPuzzle, { stripInputs, gridInputs });

            // Apply strip feedback
            result.stripFeedback.forEach(({ index, correct }) => {
                const input = document.querySelector(`[data-strip-index="${index}"]`);
                if (input) {
                    input.classList.toggle('correct', correct);
                    input.classList.toggle('incorrect', !correct);
                }
            });

            // Apply grid feedback
            result.gridFeedback.forEach(({ index, correct }) => {
                ['num1', 'op', 'num2'].forEach(type => {
                    const input = document.querySelector(`[data-grid-index="${index}"][data-input-type="${type}"]`);
                    input.classList.toggle('correct', correct);
                    input.classList.toggle('incorrect', !correct);
                });
            });

            // Show result
            alert(TetonorValidator.formatErrorMessage(result));
        }

        // Event listeners
        document.getElementById('prev-btn').addEventListener('click', () => {
            const { seed, difficulty } = parseHash();
            updateHash(Math.max(1, seed - 1), difficulty);
        });

        document.getElementById('next-btn').addEventListener('click', () => {
            const { seed, difficulty } = parseHash();
            updateHash(seed + 1, difficulty);
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            if (confirm("Reset current puzzle progress?")) {
                const { seed, difficulty } = parseHash();
                localStorage.removeItem(`tetonor_${difficulty}_${seed}`);
                updateHash(seed, difficulty);
                renderPuzzle();
            }
        });

        ['easy', 'medium', 'hard'].forEach(diff => {
            const btn = document.getElementById(`diff-${diff}`);
            if (btn) {
                btn.addEventListener('click', () => {
                    const { seed } = parseHash();
                    updateHash(seed, diff);
                });
            }
        });

        document.getElementById('solve-btn').addEventListener('click', () => {
            if (!currentPuzzle) return;

            // Show loading state or similar if needed
            const btn = document.getElementById('solve-btn');
            const originalText = btn.textContent;
            btn.textContent = "‚åõ Solving...";
            btn.disabled = true;

            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                const solution = solver.solve(currentPuzzle.grid, currentPuzzle.strip);

                if (solution) {
                    // 1. Fill Strip
                    solution.strip.forEach((val, i) => {
                        const input = document.querySelector(`[data-strip-index="${i}"]`);
                        if (input) input.value = val;
                    });

                    // 2. Fill Grid
                    solution.grid.forEach((cell, i) => {
                        if (cell) {
                            document.querySelector(`[data-grid-index="${i}"][data-input-type="num1"]`).value = cell.num1;
                            document.querySelector(`[data-grid-index="${i}"][data-input-type="op"]`).value = cell.op;
                            document.querySelector(`[data-grid-index="${i}"][data-input-type="num2"]`).value = cell.num2;
                        }
                    });

                    saveState();
                    alert("Puzzle solved! All inputs have been filled.");
                } else {
                    alert("Could not find a solution for this puzzle configuration.");
                }

                btn.textContent = originalText;
                btn.disabled = false;
            }, 10);
        });

        document.getElementById('check-btn').addEventListener('click', checkSolution);
        window.addEventListener('hashchange', renderPuzzle);

        renderPuzzle();

    </script>
</body>

</html>